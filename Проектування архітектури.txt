1. Схема основних компонентів

Уявіть три великі блоки, що взаємодіють по черзі:
Клієнт (Frontend):
Це те, що бачить користувач у своєму браузері.
Це веб-додаток, написаний на JavaScript (наприклад, з використанням фреймворків React, Angular або Vue).
Він не містить бізнес-логіки. Його завдання — відображати дані (проекти, завдання) та надсилати дії користувача (наприклад, "створити завдання") на сервер.
Сервер (Backend):
Це "мозок" системи, який працює на сервері.
Він отримує запити від клієнта (Frontend) через API (Application Programming Interface) — чіткий набір правил (наприклад, POST /api/projects для створення проекту).
Саме тут живе вся бізнес-логіка: перевірка прав доступу, логіка зміни статусів завдань, розрахунок оцінок тощо.
Він єдиний, хто має прямий доступ до бази даних.
База Даних (Database):
Це "довготривала пам'ять" системи.
Тут зберігаються всі дані: інформація про користувачів (студенти, викладачі), їхні ролі, список проектів, зміст завдань, коментарі та виставлені оцінки.
Це може бути реляційна (наприклад, PostgreSQL) або нереляційна (наприклад, MongoDB) база даних.
2. Взаємодія компонентів 
Давайте розглянемо сценарій: "Студент-лідер створює нове завдання для розробника".
Клієнт (Frontend): Лідер заповнює форму "Створити завдання" в інтерфейсі (вводить назву, опис, обирає виконавця) і натискає кнопку "Створити".
API Запит: Frontend формує з цих даних об'єкт (наприклад, у форматі JSON) і надсилає його на Сервер за адресою POST /api/tasks.
Сервер (Backend):
Отримує запит.
Автентифікація: Спершу перевіряє, чи користувач увійшов у систему.
Авторизація: Далі перевіряє, чи має цей користувач право створювати завдання (тобто, чи є він "Лідером" або "Викладачем").
Бізнес-логіка: Якщо права підтверджено, сервер створює новий запис завдання.
Збереження: Сервер надсилає команду Базі Даних на збереження цього нового завдання.
База Даних (Database): Зберігає завдання і присвоює йому унікальний ID.
Відповідь:
База Даних повідомляє Серверу про успішне збереження.
Сервер надсилає Клієнту відповідь (наприклад, 201 Created разом з даними нового завдання, включаючи його ID).
Клієнт (Frontend): Отримує відповідь і миттєво відображає нове завдання у колонці "Заплановано" на Kanban-дошці.
3. Обґрунтування вибору архітектурного підходу
Для цього проекту я рекомендую Монолітну архітектуру (або, точніше, "Модульний Моноліт"), а не мікросервісну.
Обґрунтування:
Простота розробки та запуску (MVP): Мікросервіси вимагають складної інфраструктури (оркестрація, service discovery, окремі бази даних), що є надмірним для студентського проекту. Моноліт — це єдиний додаток, який набагато легше розробити, протестувати та запустити. Це дозволяє швидко отримати MVP (Minimum Viable Product).
Відсутність мережевих проблем: В мікросервісах компоненти (наприклад, сервіс проектів і сервіс завдань) спілкуються по мережі. Це створює затримки та потенційні точки відмови. У моноліті всі модулі знаходяться в одному процесі, і виклик функції з модуля "Проекти" до модуля "Завдання" є миттєвим та надійним.
Масштабування не є проблемою (поки що): Мікросервіси зазвичай обирають для високонавантажених систем, де потрібно незалежно масштабувати окремі частини (наприклад, "сервіс завдань" навантажений сильніше, ніж "сервіс оцінювання"). Для даної системи навантаження навряд чи буде екстремальним, і моноліт можна легко масштабувати "вертикально" (додаючи ресурси серверу) або "горизонтально" (запускаючи кілька копій всього моноліту).
"Модульний моноліт" означає, що хоча весь код знаходиться в одній програмі, він чітко розділений на папки/модулі, які логічно відповідають майбутнім мікросервісам (наприклад, auth, projects, tasks, grading). Це зберігає код чистим і залишає можливість у майбутньому, якщо система виросте, легко "вирізати" ці модулі в окремі мікросервіси.

